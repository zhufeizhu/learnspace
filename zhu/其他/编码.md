# Utf-8

## Ascii
说到字符编码 首先想到的是`ASCII` 全称就是`American Standard Code for Information Interchange` 顾名思义 就是为了米国人使用的编码
而米国人需要用到的符号很少 除了控制符 大小写英文字母以及一些特殊符号之外 总和加起来也没有超过128个 因此对于`Ascii`码来说 使用1个字节
即8bit来进行表示即可 但是对于非英文国家就无法使用 像汉字的数量就远远超过了128个 因此各个国家都有一套自己的类似Ascii的编码方式 这就导致
了同样的文本 采用不同的编码方式看到的结果不同 因此就需要有一种统一的编码 就是ISO提出的Unicode

## Unicode
`Unicode`其实就是字符集 规定了`U+0000~U+FFFF`对应不同的字符 因此只要知道这种对应关系 就可以知道一段二进制编码对应的是哪个字符 例如(以UCS-2为例 即每个unicode占用2个字节) 

- `U->\u0055`
- `n->\u006e`
- `i->\u0069`
- `c->\u0063`
- `o->\u006f`
- `d->\u0064`
- `e->\u0065`

可以看到对于英文字符来说 其`Unicode`的值与`Ascii`值相同 只占用了1个字节 第一个字节为0

- `编->\u7f16` 
- `码->\u7801`

对于中文字符来说 两个字节都有使用 这就很容易想到了空间浪费的问题 这里采用的是UCS-2 标准Unicode采用的是4个字节 即一个英文字符用到了最后一个字节 前三个字节都为0 因此需要采用某种**编码方式**减少这种浪费 也就是我们说的`Utf-8`

## Utf-8
`Utf-8`很简单 顾名思义 即以8个bit为最小的处理单位 编码采用了<描述 + 内容>的方式，其中
* 描述：一组8bit二进制 从头开始有多少个1表示占用多少个字节 如1110xxxx 表示该字符包括描述字节有三个字节
* 内容：形式为10xxxxxx 其中x表示填充的内容

以 `编` 为例 其二进制编码为

`01111111 00010110` 

因此加上描述有3个字节 其组织形式为 

`1110xxxx 10xxxxxx 10xxxxxx` 

将原始内容从后往前填充至x即可 最后得到的Utf-8编码为

`11100111 10111100 10010110`

写代码测试一下
```C
#include <stdio.h>
#include <unistd.h>
#include <sys/fcntl.h>
#include <assert.h>

int main(){
    int fd = open("test.txt",O_RDONLY);
    assert(fd != 0);

    char buf[1024];

    int len = 0;
    while((len = read(fd,buf,1024)) > 0){
        for(int i = 0; i < len; i++){
            printf("%hx\n",buf[i]);
        }
    }

    close(fd);
    return 0;
}
```

得到的结果为
```
ffe7
ffbc
ff96
```
即上述计算得到的结果
