# 右值引用

老问题了 之前看过很多遍 但也就是简单的记了一下 今天看到`chrome`的`callback` 为了实现链式调用 有很多**右值引用**的写法 就再一次的学习一下

右值即不具名变量 可以理解为无法取地址的值
```c++
    int&& a = 1;
    int&& c = GetA();
    int&& b = std::move(a);
```
以上三种
- 1是临时值 
- GetA()返回的是临时值
- std::move()返回的是右值引用
这里需要注意的是 `a` `b` `c`三个都是变量 即为左值 因此如下的写法是不行的
```c++
    int&& a = 1;
    int&& b = a;
``` 

整理一下就是
**右值引用仅能用右值赋值**
**左值引用也只能用左值赋值**
**左值可以被右值赋值**
**右值不能被左值赋值**

1. 普通左值引用不能接受右值引用 例如
```c++
    A GetA(){return A();}
    A& a = GetA();
```
这样是会报错的 因为`GetA()`的返回值就是一个右值引用 但是**左值**是或者**const左值引用**可以被右值引用赋值的 例如同样的`GetA`函数
```c++
    const A& a = GetA();
    //或者
    A a = GetA();
```
都是可以的

这里为什么`GetA()`返回的是一个右值引用,可以参考深度探索C++对象模型(个人理解是返回值本质上其实是编译器产生的一个临时变量 return的值经过了两次拷贝才返回)

2. 右值引用的变量既可以是左值也可以是右值 例如
```c++
    template<typename T>
    void func(T&& a);

    //调用时
    func(1);
    int x = 1;
    func(x);
```
这里的意思难以理解 当做是右值引用的一个特点 **即在进行自动推断时，如果被左值初始化就是左值 如果被右值初始化就是右值**
因此 由于右值引用的不确定性 引出了很多新的问题 如移动语义和完美转发

3. 引用折叠
其实就两条
- 右值引用的右值引用是右值引用
即&& && 会被折叠成&&
- 其他的都是左值引用
即& &&、&& &、& &都会被折叠成&

4. std::move
别和移动构造弄混了 它的唯一作用就是将左值转换为右值引用 需要配合移动构造来节省拷贝开销
```c++
    std::vector<int> vec1 = {1,2,3};
    std::vector<int> vec2 = vec1;
    std::vector<int> vec3 = std::move(vec1);
```
这里就讲vec1的资源转移到了vec3的名下 具体怎么转移的需要看std::vector的移动构造是怎么实现的了 因此对于一些基本类型来说 没啥用
```c++
    char a[20] = "hello world";
    char b[20] = std::move(a);
```

5. std::forward
在前面说过 在进行自动推断时 右值引用可能被右值赋值 也可能被左值赋值 还是上面的例子
```c++
    template<typename T>
    void func(T&& a);

    //调用时
    func(1);
    func(x);
```
在`func`被调用时 a可以是左值 也可以是右值 这个特性让`&&`作为一个模糊的参数 在上面两个函数被调用时 最终a的类型都被当做了&

想要保证a的类型为原本的类型 就需要用到**std::forward**即
```c++
    template<typename T>
    void func(T&& a){
        f(std::forward<T>(a));
    }
```
这样在调用`f`的时候 `a`如果是`&&`就调用`f(&&)` 如果是`&`就调用`f(&)` 否则统一调用`f(&)` 因为这里的a肯定是个左值(变量都是左值)


看了这么多 尝试重新看一下`chromium`的`callback`